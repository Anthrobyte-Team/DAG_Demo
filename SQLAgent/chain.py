import logging
from langchain_community.tools.sql_database.tool import QuerySQLDatabaseTool
from .llm_setup import llm
from .prompt_template import query_prompt_template, chart_prompt_template
from .db_connection import db
from .schema import State, QueryOutput

logger = logging.getLogger(__name__)

# Function to write SQL query based on user question
def write_query(state: State):
    logger.info(f"Generating SQL query for question: {state['question']}")
    if not db:
        logger.error("Database connection is not available. Cannot write query.")
        return {"query": ""}

    prompt = query_prompt_template.invoke(
        {
            "dialect": db.dialect,
            "top_k": 10,
            "table_prompt": state.get("tables_prompt", ""),
            "table_descriptions": state.get("table_descriptions", state.get("tables_prompt", "")),
            "input": state["question"],
        }
    )
    structured_llm = llm.with_structured_output(QueryOutput)
    try:
        result = structured_llm.invoke(prompt)
        logger.info(f"Generated query: {result['query']}")
        return {"query": result["query"]}
    except Exception as e:
        logger.error(f"Failed to generate query: {e}")
        return {"query": ""}

# Executes the SQL query generated by the write_query function
def execute_query(state: State):
    """
    Executes the generated SQL query and returns the result.
    """
    logger.info(f"Executing query: {state['query']}")
    if not db:
        logger.error("Database connection is not available. Cannot execute query.")
        return {"result": "Error: Database not connected."}
    if not state.get("query"):
        logger.error("Empty SQL query. Skipping execution.")
        return {"result": "Error: empty SQL query."}

    execute_query_tool = QuerySQLDatabaseTool(db=db)
    try:
        result = execute_query_tool.invoke(state["query"])
        logger.info(f"Query executed successfully. Result: {result}")
        return {"result": result}
    except Exception as e:
        logger.error(f"Failed to execute query: {e}")
        return {"result": f"Error executing query: {e}"}

# Generates a final answer from the query results
def generate_answer(state: State):
    """
    Answers the user's question using the retrieved information as context.
    """
    logger.info("Generating final answer from results.")
    prompt = (
        "Given the following user question, corresponding SQL query, "
        "and SQL result, answer the user question.\n\n"
        f"Question: {state['question']}\n"
        f"SQL Query: {state['query']}\n"
        f"SQL Result: {state['result']}"
    )
    try:
        response = llm.invoke(prompt)
        logger.info("Final answer generated successfully.")
        return {"answer": response.content}
    except Exception as e:
        logger.error(f"Failed to generate answer: {e}")
        return {"answer": "Error generating answer."}

# Generate chart code if needed
def generate_chart_code(state: State):
    """
    Uses LLM to decide if a chart is needed and generates Plotly code.
    """
    logger.info("Generating chart code from SQL result.")
    prompt = chart_prompt_template.invoke({
        "question": state["question"],
        "query": state["query"],
        "result": state["result"]
    })
    try:
        response = llm.invoke(prompt)
        chart_code = response.content.strip()
        logger.info("Chart code generated.")
        return {"chart_code": chart_code}
    except Exception as e:
        logger.error(f"Failed to generate chart code: {e}")
        return {"chart_code": ""}